# -*- coding: utf-8 -*-
"""tamrin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MWma1m-tCKpDVXW9Le2VJtsr4fK7_2kv
"""

import random
import pandas as pd
import numpy as np
import time
import matplotlib.pyplot as plt

def max(lst):
  x=lst[0]
  for i in range (1 , len(lst)):
    if lst[i]> x :
      x= lst[i]
  return x

def f(x,y,n):
  if x>y:
    for i in range (n):
      print(i)
  else:
    for i in range (n):
      for j in range (n):
        print (i , j)

import matplotlib.pyplot as plt

lst = [10,100,1000,10000,100000,1000000]
def avg (s):
  n = len(s)
  A=[0]*n
  for j in range (n):
    total=0
    for i in range(j+1):
      total += s[i]
    A[j]= total/(j+1)
  return A

avg_lst = avg(lst)

plt.plot(avg_lst)
plt.xlabel('index')
plt.ylabel('average')
plt.title('Average value in list')
plt.show()

import matplotlib.pyplot as plt

lst = [1,2,3,4,5,6,7,8,9,10]

def max (lst):
  x = lst [0]
  for i in range(1,len(lst)):
    if lst[i]>x:
      x = lst[i]
  return x

plt.plot(lst)
plt.xlabel('index')
plt.ylabel('value')
plt.title('max value in list')
plt.show()

def disjoint(A,B,C):
  for a in A:
    for b in B:
      if a == b:
       for c in C:
        if a == c:
          return False

def disjoint(A , B , C):
  for a in A:
    for b in B:
      for c in C:
        if (a ==b == c):
          return False
    return True

def r(a):
  n = len (a)
  x = [None]*n
  for j in range (n):
    x[n-1-j]= a[j]
    return x

def r(a):
  n = len (a)
  for i in range (n//2):
    a[i], a[n-1 -i]=a[n-1-i],a[i]
  return a

def a(n):
  for j in range (n):
   i = 1
   while i <n :

      i *2

class Queue:
  def __init__ (self , k):
    self.k = k
    self.queue=[None]*k
    self.front= -1
    self.rear = -1

class Queue:
   def disqueue (self):
    if self.front == -1:
      print('empty')
      for i in range (self.front , self.rear+1):
        print(self.queue[i])

def insqueue(self , data):
  if (self.rear == -1):
    self.front=0
    self.rear = 0
    self.queue[0]=data
    if(self.rear +1 == self.k):
      print('is full')
      return
    else:
      self.rear +=1
      self.queue[self.rear]= data

def delqueue(self):
  if (self.front== -1):
    print('empty')
  elif self.front== self.rear:
      t= self.queue[self.front]
      self.front= -1
      self.rear = -1
      return t
  else:
        t= self.queue[self.front]
        self.front= -1
        return t

def insqueue_c(self , data ,k):
  if ((self.rear+1)% k ==self.front):
    print ('full')
  elif(self.front== -1):
      self.front=0
      self.rear = 0
      self.queue[self.rear]= data
  else:
      self.rear +=1
      self.queue[self.rear]= data

class stack():
  def __init__ (self,limit =10):
    self.stack =[]
    self.limit =limit

def pop(self):
  if len(self.stack)<= 0:
    return -1
  else:
    return self.stack.pop()

def peek(self):
  if len (self.stack)<=0:
    return -1
  else:
    return self.stack[len(self.stack)-1]

def push(self , data):
  if len(self.stack)>= self.limit:
    return -1
  else:
    self.stack.append(data)

def display(self):
  if len (self.stack)<=0:
    return -1
  else:
    for i in self.stack:
      print(i)

def dec2bin(number):
  s = stack()
  while number >0:
    r = number%2
    s.push(r)
    number = number//2
    b = ""
  while not s.is_empty():
    b = b +str(s.pop())
  return b

def is_empty(self):
  if len (self.stack)<=0:
    return True
  else:
    return False

def reverse(lst):
  s=stack()
  for e in lst:
    s.push(e)
  for i in range (len (lst)):
    lst[i]= s.pop()

def reverse_stack(s):
  s1=stack()
  s2 = stack()
  while not s.is_empty():
    s1.push(s.pop())
  while not s1.is_empty():
    s2.push(s1.pop())
  while not s2.is_empty():
    s.push(s2.pop())

def respost(Lst) :
  s = stack((len(Lst)) // 2 )
  for e in Lst :
    if e == '*' :
      t2 = s.pop()
      t1 : s.pop()
      t = t1 * t2
      s.push(t)
  else :
    s.push(e)
  return s.stack[0]

def Match_s(str) :
  s=stack()
  for i in str :
    if i in '([{' :
      s.push(i)
    elif i in ')]}' :
      if s.peek() == i :
        s.pop()
      else :
         return False
  if s.is_empty() :
    return True
  else :
    return False

class node :
  def __init__(self , d):
    self.data = d
    self.next = None

class Linkedlist :
  def __init__(self):
    self.head = None

def display(self) :
  t = node()
  t = self.head
  while (t != None) :
    print (t.data , end = ' --> ')
    t = t.next
    print ('None')

def addinstart (self , data) :
  n = node (data)
  n.next = self.head
  self.head = n

def addinend (self , data) :
  n = node(data)
  t = self.head
  if (t == None):
    self.head = n
  else :
    while (t.next) :
      t = t.next
    t.next = n

class Linkedlist :
  def __init__(self) :
    self.head = None
  def addafter(self,m,d) :
    n = node(d)
    t = self.head
    while (t.data != m) :
      t = t.next
      t.next = n

def delfirst(self) :
  if(self.head == None) :
    return 'empty'
  else :
    self.head = self.head.next

def dellast (self) :
  if (t== None )
  while (t.next.next != None ) :
    t = t.next
  t.next = None

def delafter (self , m):
  t = self.head
  while (t.data != m) :
    t = t.next
  t.next = t.nex.next

class dnode :
  def __init__(self , data) :
    self.data = data
    self.next = None
    self.prev = None

class dLinkedlist :
  def __init__ (self) :
    self.head = None
  def display (self):
    t =self.head
    while (t !=None) :
      print (t.data ,' <--> ')
      t = t.next
    print('None')

def addinstart (self , d) :
  n = dnode()
  if self.head != None
     n.next = self.head
     self.head.prev = n
  self.head = n

def addinend (self , d) :
  n = dnode(d)
  if self.head != None :
    t = self.head
    while (t.next != None) :
      t = t.next
    t.next = n
    n.prev = t
  else :
    self.head = n

def delfirst(self) :
  if(self.head == None) :
    return -1
  self.head = self.head.next
  self.head.prev.none

def delmid(self) :
  t = self.head
  count = 0
  while (t!=None):
    t = t.next
    count += 1
  t = self.head
  if count % 2 == 0 :
   for i in range ( count // 2) :
    t = t.next
  else :
   for i in range (count //2 +1) :
    t = t.next
  t.next.prev = t.prev
  t.prev.next = t.next
  t.next = None
  t.prev = None

class cLinkedlist :
  def __init__(self) :
    self.head = None
  def display(self) :
    t = self.head
    if t is None :
      print("empty")
      return
    while t.next != self.head :
      print(t.data , end = ' --> ')
      t = t.next
    print(t.data)

def addafter (self , m , data ) :
  if self.head  == None :
     return -1
     n = node(data)
     t = self.head
  while t.data != m:
      t = t.next
      if t == self.head :
        return -1

def delete (self , data ) :
  if self.head == None :
    print ("empty")
    return
  if self.head.next == self.head :
    if self.head.data == data :
      self.head = None
      return
    return -1
  t = self.head
  while (t .data != data ) :
    p = t
    t = t.next
    if t == self.head :
      return -1
  p.next = t.next
  t.next = None

class BTnode() :
  def __init__(self , data , left = None , right = None ) :
    self.data = data
    self.left = left
    self.right = right

class Btree() :
  def __init__(self , root = None ) :
    self.rot = root
  def inorder(self , root ) :
    if (root == None ) :
      return
    else :
      self.inorder(root.left)
      print(root.data)
      self.inorder(root.right)

class NodeBST :
  def __init__(self , data ) :
    self.key = data
    self.Left = None
    self.Right = None

def secondBST (root , k) :
  if root is None or root.key == k :
    return root
  if k > root.key :
    return secondBST (root.Right , k)
  return secondBST(root.Lest , k)

def insertBST (root , k) :
  if root is None :
    return NodeBST(k)
  if k < root.key :
    root.Left = insertBST (root.Left , k)
  else :
    root.Right = insertBST(root.Right , k)
  return
r = NodeBST(5)
insertBST(r,3)

def minvalueBST(root) :
  if root is None :
    return root
  while root.Left is not None :
    root = root.Left
  return root.key

def minNodeBST(r) :
  if r.Left is None :
    return r
  else :
    minNodeBST(r.Left)
  return

def heapify(A,K):
  Left = 2 * K +1
  right = 2 * K + 2
  if Left < len(A) and A[Left] < A[K] :
    S = 1
  else :
    S = K
  if right < len(A) and A[right] < A[S] :
    S = right
  if S!= K :
    A[K] ,  A[S] = A[S] , A[K]
    heapify[A,S]

def build_min_heap(A):
  n = int ((len(A)//2)-1)
  for k in range (n , -1 ,-1):
     heapify(A,K)
  A =[5,6,3,1,4,2,7]
  build_min_heap(A)
  print(A)

class Graph():
  def __init__(self, n=3):
    self.size =n
    self.m =[]
    for i in range (n):
      self.m.append([0 for i in range()])

def add_edge(self , v1 ,v2):
  self.m[v1][v2]=1
  self.m [v2] [v1]=1

def display(self):
  for i in range (self.size):
    for j in range (self.size):
      print (self.m [i] [j] , end= '')
      print()